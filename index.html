<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Path Finder & Graph Algorithms Visualizer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <!-- Navigation Links for Easy Section Jumping -->
  <nav class="navbar">
    <a href="#intro"><b>GRAPHS INTRO</b></a>
    <a href="#algorithms"><b>GRAPH ALGORITHMS</b></a>
    <a href="#shortest-path"><b>SHORTEST PATH</b></a>
  </nav>
  <div class="section" id="intro">
    <h1><b>GRAPHS: THE BASICS</b></h1>
    <p>
      <b>What is a graph?</b><br>
      A <b>graph</b> is a way to represent connections between things. Each item is a <b>node</b> (or vertex), and each connection is called an <b>edge</b>.<br><br>
      <b>Real-life examples:</b>
      <ul>
        <li>Social networks (people as nodes, friendships as edges)</li>
        <li>Maps (places as nodes, roads as edges)</li>
        <li>Internet (computers as nodes, cables as edges)</li>
      </ul>
      <b>Types of graphs:</b>
      <ul>
        <li><b>Undirected:</b> Connections go both ways (like a two-way street)</li>
        <li><b>Directed:</b> Connections have a direction (like a one-way street)</li>
        <li><b>Weighted:</b> Edges have a value (like road distance)</li>
        <li><b>Unweighted:</b> All connections are equal</li>
      </ul>
    </p>
    <canvas id="graph-canvas-intro" width="400" height="200"></canvas>
    <p>
      <i>This is a simple undirected, unweighted graph. Each circle is a node, and each line is an edge.</i>
    </p>
  </div>

  <div class="section" id="algorithms">
    <h1><b>GRAPH ALGORITHMS: BFS & DFS</b></h1>
    <h2><b>BREADTH-FIRST SEARCH (BFS)</b></h2>
    <p>
      <b>BFS</b> is like exploring a maze layer by layer. Imagine you are at node "A" and want to visit every place you can reach, moving outward step by step.
      <br><br>
      <b>How BFS works:</b>
      <ol>
        <li>Start at the chosen node (e.g., A)</li>
        <li>Visit all direct neighbors</li>
        <li>Then visit neighbors of those neighbors</li>
        <li>Continue until all nodes are visited</li>
      </ol>
      <b>Uses:</b> Finding the shortest path in unweighted graphs, social networks, maps.
      <br>
      <button onclick="runBFS()">Run BFS Demo</button>
    </p>
    <h2><b>DEPTH-FIRST SEARCH (DFS)</b></h2>
    <p>
      <b>DFS</b> is like exploring as far as you can go down one path before backtracking.
      <br><br>
      <b>How DFS works:</b>
      <ol>
        <li>Start at the chosen node</li>
        <li>Go to one neighbor, then its neighbor, as deep as you can</li>
        <li>If you reach a dead end, back up and try the next path</li>
        <li>Continue until all nodes are visited</li>
      </ol>
      <b>Uses:</b> Solving puzzles, analyzing networks, finding connected components.
      <br>
      <button onclick="runDFS()">Run DFS Demo</button>
    </p>
    <canvas id="graph-canvas-algo" width="400" height="300"></canvas>
    <div id="algo-output"></div>
  </div>

  <div class="section" id="shortest-path">
    <h1><b>SHORTEST PATH IN GRAPHS</b></h1>
    <p>
      <b>What is the shortest path?</b><br>
      The shortest path between two nodes is the path with the fewest edges (or lowest total weight in weighted graphs).
      <br><br>
      <b>How do we find it?</b><br>
      For unweighted graphs, <b>Breadth-First Search (BFS)</b> is the simplest way to find the shortest path.
      <br><br>
      <b>Step-by-step:</b>
      <ol>
        <li>Start at the source node</li>
        <li>Explore neighbors layer by layer</li>
        <li>Track how you got to each node</li>
        <li>Once you reach the target node, trace back your steps</li>
      </ol>
      <button onclick="runShortestPath()">Show Shortest Path (A to F)</button>
    </p>
    <canvas id="graph-canvas-path" width="400" height="300"></canvas>
    <div id="path-output"></div>
    <hr>
    <h2><b>SUMMARY & KEY POINTS</b></h2>
    <ul>
      <li>Graphs help model connections in the real world</li>
      <li>BFS explores layer by layer, DFS goes deep before backtracking</li>
      <li>BFS is best for shortest path in unweighted graphs</li>
      <li>Visualizing algorithms helps understand how they work</li>
    </ul>
  </div>

  <!-- Easy-to-understand JavaScript with comments -->
  <script>
    // ---------------------------
    // Graph Data for all sections
    // ---------------------------
    // 6 nodes, undirected, unweighted. Labels: A-F
    const nodes = [
      {x: 80, y: 80, label: 'A'},
      {x: 320, y: 80, label: 'B'},
      {x: 200, y: 40, label: 'C'},
      {x: 200, y: 180, label: 'D'},
      {x: 80, y: 220, label: 'E'},
      {x: 320, y: 220, label: 'F'}
    ];
    // Edges connect pairs of node indices
    const edges = [
      [0, 2], [2, 1], [0, 3], [1, 3], [3, 4], [3, 5], [4, 5]
    ];

    // ---------------------------
    // Drawing Functions
    // ---------------------------
    // Draw the graph with optional highlighted nodes
    function drawGraph(canvasId, highlighted=[]) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw edges
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      for (let [a, b] of edges) {
        ctx.beginPath();
        ctx.moveTo(nodes[a].x, nodes[a].y);
        ctx.lineTo(nodes[b].x, nodes[b].y);
        ctx.stroke();
      }

      // Draw nodes
      for (let i = 0; i < nodes.length; i++) {
        ctx.beginPath();
        ctx.arc(nodes[i].x, nodes[i].y, 22, 0, 2 * Math.PI);
        ctx.fillStyle = highlighted.includes(i) ? '#ffd700' : '#43c6ac';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.stroke();
        ctx.fillStyle = '#222';
        ctx.font = 'bold 17px Segoe UI';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(nodes[i].label, nodes[i].x, nodes[i].y);
      }
    }

    // Draw static graphs on each section at page load
    window.onload = function() {
      drawGraph('graph-canvas-intro');
      drawGraph('graph-canvas-algo');
      drawGraph('graph-canvas-path');
    };

    // ---------------------------
    // Algorithm Functions
    // ---------------------------
    // BFS: returns order visited + how we got to each node
    function bfs(start, end=null) {
      let visited = Array(nodes.length).fill(false);
      let queue = [start];
      let order = [];
      let prev = Array(nodes.length).fill(-1);
      visited[start] = true;
      while (queue.length > 0) {
        let node = queue.shift();
        order.push(node);
        if (node === end) break;
        for (let [a, b] of edges) {
          let neighbor = null;
          if (a === node) neighbor = b;
          else if (b === node) neighbor = a;
          if (neighbor !== null && !visited[neighbor]) {
            queue.push(neighbor);
            visited[neighbor] = true;
            prev[neighbor] = node;
          }
        }
      }
      return {order, prev};
    }

    // DFS: returns order visited + how we got to each node
    function dfs(start, end=null) {
      let visited = Array(nodes.length).fill(false);
      let stack = [start];
      let order = [];
      let prev = Array(nodes.length).fill(-1);
      visited[start] = true;
      while (stack.length > 0) {
        let node = stack.pop();
        order.push(node);
        if (node === end) break;
        for (let [a, b] of edges) {
          let neighbor = null;
          if (a === node) neighbor = b;
          else if (b === node) neighbor = a;
          if (neighbor !== null && !visited[neighbor]) {
            stack.push(neighbor);
            visited[neighbor] = true;
            prev[neighbor] = node;
          }
        }
      }
      return {order, prev};
    }

    // Reconstruct path from prev array
    function reconstructPath(prev, start, end) {
      let path = [];
      for (let at = end; at !== -1; at = prev[at]) path.push(at);
      path.reverse();
      if (path[0] !== start) return [];
      return path;
    }

    // Helper for node index by label
    function labelToIndex(label) {
      return nodes.findIndex(n => n.label === label);
    }

    // Animation helpers
    async function animateOrder(canvasId, order) {
      for (let i = 0; i < order.length; i++) {
        drawGraph(canvasId, order.slice(0, i+1));
        await new Promise(res => setTimeout(res, 600));
      }
      drawGraph(canvasId, order);
    }

    // ---------------------------
    // Button Actions
    // ---------------------------
    async function runBFS() {
      document.getElementById('algo-output').innerText = 'Running BFS from A...';
      const {order} = bfs(0); // Start at node A
      await animateOrder('graph-canvas-algo', order);
      document.getElementById('algo-output').innerText =
        'BFS visit order: ' + order.map(i => nodes[i].label).join(' → ');
    }

    async function runDFS() {
      document.getElementById('algo-output').innerText = 'Running DFS from A...';
      const {order} = dfs(0); // Start at node A
      await animateOrder('graph-canvas-algo', order);
      document.getElementById('algo-output').innerText =
        'DFS visit order: ' + order.map(i => nodes[i].label).join(' → ');
    }

    async function runShortestPath() {
      document.getElementById('path-output').innerText = 'Finding shortest path from A to F...';
      const {prev} = bfs(0, 5); // BFS for shortest path from A to F
      const path = reconstructPath(prev, 0, 5);
      await animateOrder('graph-canvas-path', path);
      document.getElementById('path-output').innerText =
        'Shortest path from A to F: ' + path.map(i => nodes[i].label).join(' → ');
    }
  </script>
</body>
</html>