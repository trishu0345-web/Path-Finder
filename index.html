<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Path Finder Visualizer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>Path Finder & Graph Algorithms Visualizer</h1>
    <p>
      <b>What are graphs?</b><br>
      A graph is a structure made up of <b>nodes</b> (also called vertices) connected by <b>edges</b>. Graphs are used to model networks like roads, social connections, and more.
    </p>
    <canvas id="graph-canvas" width="400" height="300"></canvas>
    <div class="algo-controls">
      <button onclick="runBFS()">Run BFS</button>
      <button onclick="runDFS()">Run DFS</button>
      <button onclick="runShortestPath()">Run Shortest Path</button>
    </div>
    <div id="algo-output"></div>
    <hr>
    <h2>Algorithms Explained</h2>
    <ul>
      <li><b>BFS (Breadth-First Search):</b> Explores nodes layer by layer, great for finding shortest path in unweighted graphs.</li>
      <li><b>DFS (Depth-First Search):</b> Explores as far as possible along each branch before backtracking.</li>
      <li><b>Shortest Path:</b> Finds the shortest route between two nodes (using BFS here for unweighted graphs).</li>
    </ul>
    <p>
      Try clicking the buttons above to see each algorithm in action on the sample graph!
    </p>
  </div>

  <script>
    // Basic graph: 6 nodes, undirected, unweighted
    const nodes = [
      {x: 80, y: 80, label: 'A'},
      {x: 320, y: 80, label: 'B'},
      {x: 200, y: 40, label: 'C'},
      {x: 200, y: 180, label: 'D'},
      {x: 80, y: 220, label: 'E'},
      {x: 320, y: 220, label: 'F'}
    ];

    // Edges: pairs of indices
    const edges = [
      [0, 2], [2, 1], [0, 3], [1, 3], [3, 4], [3, 5], [4, 5]
    ];

    // Draw graph
    function drawGraph(highlighted=[]) {
      const canvas = document.getElementById('graph-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw edges
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      for (let [a, b] of edges) {
        ctx.beginPath();
        ctx.moveTo(nodes[a].x, nodes[a].y);
        ctx.lineTo(nodes[b].x, nodes[b].y);
        ctx.stroke();
      }

      // Draw nodes
      for (let i = 0; i < nodes.length; i++) {
        ctx.beginPath();
        ctx.arc(nodes[i].x, nodes[i].y, 22, 0, 2 * Math.PI);
        ctx.fillStyle = highlighted.includes(i) ? '#ffd700' : '#43c6ac';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.stroke();
        ctx.fillStyle = '#222';
        ctx.font = 'bold 17px Segoe UI';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(nodes[i].label, nodes[i].x, nodes[i].y);
      }
    }

    drawGraph();

    // Algorithm helpers
    function bfs(start, end=null) {
      let visited = Array(nodes.length).fill(false);
      let queue = [start];
      let order = [];
      let prev = Array(nodes.length).fill(-1);
      visited[start] = true;
      while (queue.length > 0) {
        let node = queue.shift();
        order.push(node);
        if (node === end) break;
        for (let [a, b] of edges) {
          let neighbor = null;
          if (a === node) neighbor = b;
          else if (b === node) neighbor = a;
          if (neighbor !== null && !visited[neighbor]) {
            queue.push(neighbor);
            visited[neighbor] = true;
            prev[neighbor] = node;
          }
        }
      }
      return {order, prev};
    }

    function dfs(start, end=null) {
      let visited = Array(nodes.length).fill(false);
      let stack = [start];
      let order = [];
      let prev = Array(nodes.length).fill(-1);
      visited[start] = true;
      while (stack.length > 0) {
        let node = stack.pop();
        order.push(node);
        if (node === end) break;
        for (let [a, b] of edges) {
          let neighbor = null;
          if (a === node) neighbor = b;
          else if (b === node) neighbor = a;
          if (neighbor !== null && !visited[neighbor]) {
            stack.push(neighbor);
            visited[neighbor] = true;
            prev[neighbor] = node;
          }
        }
      }
      return {order, prev};
    }

    function reconstructPath(prev, start, end) {
      let path = [];
      for (let at = end; at !== -1; at = prev[at]) path.push(at);
      path.reverse();
      if (path[0] !== start) return [];
      return path;
    }

    // Animation helpers
    async function animateOrder(order) {
      for (let i = 0; i < order.length; i++) {
        drawGraph(order.slice(0, i+1));
        await new Promise(res => setTimeout(res, 600));
      }
      drawGraph(order);
    }

    function labelToIndex(label) {
      return nodes.findIndex(n => n.label === label);
    }

    // UI actions
    async function runBFS() {
      document.getElementById('algo-output').innerText = 'Running BFS from A...';
      const {order} = bfs(0); // Start at node A
      await animateOrder(order);
      document.getElementById('algo-output').innerText =
        'BFS visit order: ' + order.map(i => nodes[i].label).join(' → ');
    }

    async function runDFS() {
      document.getElementById('algo-output').innerText = 'Running DFS from A...';
      const {order} = dfs(0); // Start at node A
      await animateOrder(order);
      document.getElementById('algo-output').innerText =
        'DFS visit order: ' + order.map(i => nodes[i].label).join(' → ');
    }

    async function runShortestPath() {
      document.getElementById('algo-output').innerText = 'Finding shortest path from A to F...';
      const {prev} = bfs(0, 5); // BFS for shortest path from A to F
      const path = reconstructPath(prev, 0, 5);
      await animateOrder(path);
      document.getElementById('algo-output').innerText =
        'Shortest path from A to F: ' + path.map(i => nodes[i].label).join(' → ');
    }
  </script>
</body>
</html>